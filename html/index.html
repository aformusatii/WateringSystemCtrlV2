<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Watering System Channels</title>
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --border: #d7dce3;
      --text: #1f2430;
      --muted: #5c6370;
      --accent: #2f80ed;
      --accent-weak: #e7f1ff;
      --danger: #d7263d;
      --shadow: 0 8px 20px rgba(31, 36, 48, 0.08);
      --radius: 10px;
      --space: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 24px;
      font-family: 'Montserrat', 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    h1 {
      margin: 0 0 8px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    p.subtitle {
      margin: 0 0 20px;
      color: var(--muted);
    }
    .grid {
      display: grid;
      gap: var(--space);
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space);
      box-shadow: var(--shadow);
    }
    .channel-head {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .chip {
      padding: 6px 12px;
      background: var(--accent-weak);
      color: var(--accent);
      border-radius: 999px;
      font-weight: 700;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }
    .input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 0.95rem;
    }
    .input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(47, 128, 237, 0.15);
    }
    .mode-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }
    .mode-btn {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #f8fafc;
      cursor: pointer;
      font-weight: 600;
      color: var(--muted);
      transition: all 0.15s ease;
    }
    .mode-btn.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 8px 16px rgba(47, 128, 237, 0.25);
    }
    .mode-btn:active { transform: translateY(1px); }
    .section-title {
      margin: 14px 0 8px;
      font-size: 0.95rem;
      color: var(--muted);
      letter-spacing: 0.02em;
      font-weight: 700;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      align-items: center;
    }
    label {
      font-size: 0.9rem;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }
    .inline {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .end-time {
      padding: 10px 12px;
      background: #f2f4f8;
      border-radius: 8px;
      border: 1px solid var(--border);
      min-width: 90px;
      text-align: center;
      font-weight: 600;
      color: var(--text);
    }
    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      margin-top: 10px;
    }
    .btn {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: box-shadow 0.15s ease, transform 0.1s ease;
    }
    .btn.secondary {
      background: #eef1f6;
      color: var(--text);
      border-color: var(--border);
    }
    .btn:active { transform: translateY(1px); }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }
    .loading {
      text-align: center;
      color: var(--muted);
      padding: 20px;
    }
    .ds-card h2 { margin: 0 0 6px; }
    .ds-meta { color: var(--muted); margin: 0 0 10px; }
    .status { color: var(--muted); font-size: 0.9rem; }
  </style>
</head>
<body>
  <div id="app" class="grid">
    <header>
      <h1>Channel Manager</h1>
      <p class="subtitle">Configure modes, timers, schedules, and sync the DS3231 clock. API endpoints remain unchanged.</p>
      <div class="status" v-if="message">{{ message }}</div>
    </header>

    <div v-if="loading" class="loading">Loading...</div>

    <section v-else class="grid">
      <article class="card" v-for="(channel, index) in channels" :key="index">
        <div class="channel-head">
          <div class="chip">CH {{ index + 1 }}</div>
          <input class="input" type="text" v-model="channel.name" :placeholder="`Channel ${index + 1}`">
        </div>

        <div class="mode-row">
          <button
            v-for="option in modeOptions"
            :key="option.key"
            class="mode-btn"
            :class="{ active: channel.mode === option.key }"
            @click="setMode(channel, option.key)">
            {{ option.label }}
          </button>
        </div>

        <div v-if="channel.mode === modeKeys.timer">
          <div class="section-title">Timer</div>
          <div class="row">
            <div>
              <label>On Period (ms)</label>
              <input class="input" type="number" min="0" :value="channel.timer.onDurationMs" @input="updateTimer(channel, 'onDurationMs', $event.target.value)">
            </div>
            <div>
              <label>Off Period (ms)</label>
              <input class="input" type="number" min="0" :value="channel.timer.offDurationMs" @input="updateTimer(channel, 'offDurationMs', $event.target.value)">
            </div>
          </div>
        </div>

        <div v-if="channel.mode === modeKeys.schedule">
          <div class="section-title">Scheduler</div>
          <div class="grid" style="gap:12px">
            <div class="inline" v-for="(slot, slotIndex) in channel.schedules" :key="slotIndex">
              <div style="font-weight:700; min-width:58px;">Slot {{ slotIndex + 1 }}</div>
              <div>
                <label>Start</label>
                <input class="input" style="min-width:120px" type="time" :value="timeString(slot)" @input="updateStart(slot, $event.target.value)">
              </div>
              <div>
                <label>Duration (min)</label>
                <input class="input" style="max-width:120px" type="number" min="0" :value="slot.durationMin" @input="slot.durationMin = toNumber($event.target.value)">
              </div>
              <div>
                <label>Ends</label>
                <div class="end-time">{{ endTime(slot) }}</div>
              </div>
            </div>
          </div>
        </div>
      </article>

      <article class="card">
        <div class="actions" style="justify-content:flex-start;">
          <button class="btn" :disabled="saving" @click="saveChannels">
            {{ saving ? 'Saving...' : 'Save Channels' }}
          </button>
          <button class="btn secondary" :disabled="loading" @click="refreshAll">Refresh</button>
        </div>
      </article>

      <article class="card ds-card">
        <h2>DS3231</h2>
        <p class="ds-meta" v-if="ds3231">
          Current Time: {{ formattedClock }}<br>
          Temperature: {{ ds3231.temperature }} °C
        </p>
        <p class="ds-meta" v-else>Loading clock data...</p>
        <div class="actions">
          <button class="btn secondary" :disabled="clockBusy" @click="refreshClock">Refresh</button>
          <button class="btn" :disabled="clockBusy" @click="updateClock">Update Time</button>
        </div>
      </article>
    </section>
  </div>

  <script src="vue.js"></script>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          modeKeys: { schedule: 1, timer: 2, manual: 3, off: 4 },
          modeOptions: [
            { key: 4, label: 'Off' },
            { key: 3, label: 'Manual' },
            { key: 2, label: 'Timer' },
            { key: 1, label: 'Scheduler' }
          ],
          channels: [],
          ds3231: null,
          loading: true,
          saving: false,
          clockBusy: false,
          message: ''
        };
      },
      computed: {
        formattedClock() {
          if (!this.ds3231) return '—';
          const y = 2000 + Number(this.ds3231.year || 0);
          return `${this.pad(this.ds3231.hour)}:${this.pad(this.ds3231.minute)}:${this.pad(this.ds3231.second)} ${this.pad(this.ds3231.day)}/${this.pad(this.ds3231.month)}/${y}`;
        }
      },
      methods: {
        pad(value) {
          return String(value).padStart(2, '0');
        },
        toNumber(value) {
          const n = parseInt(value, 10);
          return Number.isFinite(n) ? n : 0;
        },
        timeString(slot) {
          return `${this.pad(slot.startHour)}:${this.pad(slot.startMinute)}`;
        },
        endTime(slot) {
          const start = (this.toNumber(slot.startHour) * 60) + this.toNumber(slot.startMinute);
          const total = start + this.toNumber(slot.durationMin);
          const hh = this.pad(Math.floor((total % 1440) / 60));
          const mm = this.pad(total % 60);
          return `${hh}:${mm}`;
        },
        updateStart(slot, value) {
          const [h, m] = value.split(':').map(v => this.toNumber(v));
          slot.startHour = h;
          slot.startMinute = m;
        },
        updateTimer(channel, key, value) {
          channel.timer[key] = this.toNumber(value);
        },
        setMode(channel, mode) {
          channel.mode = mode;
        },
        async loadChannels() {
          const res = await fetch('channels.json');
          if (!res.ok) throw new Error(res.statusText);
          this.channels = await res.json();
        },
        async loadClock() {
          const res = await fetch('DS3231.json');
          if (!res.ok) throw new Error(res.statusText);
          this.ds3231 = await res.json();
        },
        async refreshAll() {
          this.loading = true;
          this.message = '';
          try {
            await Promise.all([this.loadChannels(), this.loadClock()]);
          } catch (err) {
            this.message = `Error loading data: ${err.message}`;
          } finally {
            this.loading = false;
          }
        },
        async saveChannels() {
          this.saving = true;
          this.message = '';
          try {
            const res = await fetch('channels.json', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(this.channels)
            });
            if (!res.ok) throw new Error(res.statusText);
            this.message = 'Channels saved';
          } catch (err) {
            this.message = `Save failed: ${err.message}`;
          } finally {
            this.saving = false;
          }
        },
        async refreshClock() {
          this.clockBusy = true;
          this.message = '';
          try {
            await this.loadClock();
          } catch (err) {
            this.message = `Clock refresh failed: ${err.message}`;
          } finally {
            this.clockBusy = false;
          }
        },
        async updateClock() {
          this.clockBusy = true;
          this.message = '';
          try {
            const now = new Date();
            const payload = {
              hour: now.getHours(),
              minute: now.getMinutes(),
              second: now.getSeconds(),
              year: now.getFullYear() - 2000,
              month: now.getMonth() + 1,
              day: now.getDate()
            };
            const res = await fetch('DS3231.json', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (!res.ok) throw new Error(res.statusText);
            await this.loadClock();
            this.message = 'Clock updated';
          } catch (err) {
            this.message = `Clock update failed: ${err.message}`;
          } finally {
            this.clockBusy = false;
          }
        }
      },
      mounted() {
        this.refreshAll();
      }
    }).mount('#app');
  </script>
</body>
</html>
