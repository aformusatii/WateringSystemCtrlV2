<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Watering System Channels</title>
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --border: #d7dce3;
      --text: #1f2430;
      --muted: #5c6370;
      --accent: #2f80ed;
      --accent-weak: #e7f1ff;
      --danger: #d7263d;
      --shadow: 0 8px 20px rgba(31, 36, 48, 0.08);
      --radius: 10px;
      --space: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 24px;
      font-family: 'Montserrat', 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    h1 {
      margin: 0 0 8px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    p.subtitle {
      margin: 0 0 20px;
      color: var(--muted);
    }
    .grid {
      display: grid;
      gap: var(--space);
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space);
      box-shadow: var(--shadow);
    }
    .channel-head {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .chip {
      padding: 6px 12px;
      background: var(--accent-weak);
      color: var(--accent);
      border-radius: 999px;
      font-weight: 700;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }
    .input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 0.95rem;
    }
    .input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(47, 128, 237, 0.15);
    }
    .mode-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }
    .mode-btn {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #f8fafc;
      cursor: pointer;
      font-weight: 600;
      color: var(--muted);
      transition: all 0.15s ease;
    }
    .mode-btn.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 8px 16px rgba(47, 128, 237, 0.25);
    }
    .mode-btn:active { transform: translateY(1px); }
    .section-title {
      margin: 14px 0 8px;
      font-size: 0.95rem;
      color: var(--muted);
      letter-spacing: 0.02em;
      font-weight: 700;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      align-items: center;
    }
    label {
      font-size: 0.9rem;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }
    .inline {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .end-time {
      padding: 10px 12px;
      background: #f2f4f8;
      border-radius: 8px;
      border: 1px solid var(--border);
      min-width: 90px;
      text-align: center;
      font-weight: 600;
      color: var(--text);
    }
    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      margin-top: 10px;
    }
    .btn {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: box-shadow 0.15s ease, transform 0.1s ease;
    }
    .btn.secondary {
      background: #eef1f6;
      color: var(--text);
      border-color: var(--border);
    }
    .btn:active { transform: translateY(1px); }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }
    .loading {
      text-align: center;
      color: var(--muted);
      padding: 20px;
    }
    .ds-card h2 { margin: 0 0 6px; }
    .ds-meta { color: var(--muted); margin: 0 0 10px; }
    .status { color: var(--muted); font-size: 0.9rem; }
    .hw-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .hw-item {
      background: #f7f9fc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
    }
    .hw-key {
      font-size: 0.85rem;
      color: var(--muted);
      margin: 0 0 4px;
    }
    .hw-val {
      margin: 0;
      font-weight: 700;
      color: var(--text);
      word-break: break-word;
    }
    .file-input {
      width: 100%;
      padding: 10px 12px;
      border: 1px dashed var(--border);
      border-radius: 8px;
      background: #f9fbff;
      cursor: pointer;
    }
    .file-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(47, 128, 237, 0.15);
    }
    .hint {
      color: var(--muted);
      font-size: 0.9rem;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div id="app" class="grid">
    <header>
      <h1>Channel Manager</h1>
      <p class="subtitle">Configure modes, timers, schedules, and sync the DS3231 clock. API endpoints remain unchanged.</p>
      <div class="status" v-if="message">{{ message }}</div>
    </header>

    <div v-if="loading" class="loading">Loading...</div>

    <section v-else class="grid">
      <article class="card" v-for="(channel, index) in channels" :key="index">
        <div class="channel-head">
          <div class="chip">CH {{ index + 1 }}</div>
          <input class="input" type="text" v-model="channel.name" :placeholder="`Channel ${index + 1}`">
        </div>

        <div class="mode-row">
          <button
            v-for="option in modeOptions"
            :key="option.key"
            class="mode-btn"
            :class="{ active: channel.mode === option.key }"
            @click="setMode(channel, option.key)">
            {{ option.label }}
          </button>
        </div>

        <div v-if="channel.mode === modeKeys.timer">
          <div class="section-title">Timer</div>
          <div class="row">
            <div>
              <label>On Period (ms)</label>
              <input class="input" type="number" min="0" :value="channel.timer.onDurationMs" @input="updateTimer(channel, 'onDurationMs', $event.target.value)">
            </div>
            <div>
              <label>Off Period (ms)</label>
              <input class="input" type="number" min="0" :value="channel.timer.offDurationMs" @input="updateTimer(channel, 'offDurationMs', $event.target.value)">
            </div>
          </div>
        </div>

        <div v-if="channel.mode === modeKeys.schedule">
          <div class="section-title">Scheduler</div>
          <div class="grid" style="gap:12px">
            <div class="inline" v-for="(slot, slotIndex) in channel.schedules" :key="slotIndex">
              <div style="font-weight:700; min-width:58px;">Slot {{ slotIndex + 1 }}</div>
              <div>
                <label>Start</label>
                <input class="input" style="min-width:120px" type="time" :value="timeString(slot)" @input="updateStart(slot, $event.target.value)">
              </div>
              <div>
                <label>Duration (min)</label>
                <input class="input" style="max-width:120px" type="number" min="0" :value="slot.durationMin" @input="slot.durationMin = toNumber($event.target.value)">
              </div>
              <div>
                <label>Ends</label>
                <div class="end-time">{{ endTime(slot) }}</div>
              </div>
            </div>
          </div>
        </div>
      </article>

      <article class="card">
        <div class="actions" style="justify-content:flex-start;">
          <button class="btn" :disabled="saving" @click="saveChannels">
            {{ saving ? 'Saving...' : 'Save Channels' }}
          </button>
          <button class="btn secondary" :disabled="loading" @click="refreshAll">Refresh</button>
        </div>
      </article>

      <article class="card">
        <h2>Direct PCF8575 Control</h2>
        <p class="ds-meta">Set a pin (0-15) HIGH or LOW instantly.</p>
        <div class="row">
          <div>
            <label for="pinNumber">Pin Number</label>
            <input id="pinNumber" class="input" type="number" min="0" max="15" v-model.number="pinCtrl.pin">
          </div>
          <div>
            <label>Current State</label>
            <div class="end-time">{{ pinCtrl.state === null ? '—' : (pinCtrl.state ? 'HIGH' : 'LOW') }}</div>
          </div>
        </div>
        <div class="actions" style="justify-content:flex-start;">
          <button class="btn" :disabled="pinCtrl.busy" @click="setPin(true)">Set HIGH</button>
          <button class="btn secondary" :disabled="pinCtrl.busy" @click="setPin(false)">Set LOW</button>
          <button class="btn secondary" :disabled="pinCtrl.busy" @click="readPin">Read</button>
        </div>
        <p class="status" v-if="pinCtrl.message">{{ pinCtrl.message }}</p>
      </article>

      <article class="card ds-card">
        <h2>DS3231</h2>
        <p class="ds-meta" v-if="ds3231">
          Current Time: {{ formattedClock }}<br>
          Temperature: {{ ds3231.temperature }} °C
        </p>
        <p class="ds-meta" v-else>Loading clock data...</p>
        <div class="actions">
          <button class="btn secondary" :disabled="clockBusy" @click="refreshClock">Refresh</button>
          <button class="btn" :disabled="clockBusy" @click="updateClock">Update Time</button>
        </div>
      </article>

      <article class="card ds-card">
        <h2>Firmware Update</h2>
        <p class="ds-meta">
          Upload a compiled ESP8266 firmware (.bin). The device will reboot automatically after a successful upload.
        </p>
        <div class="row">
          <div>
            <label for="firmwareFile">Firmware File</label>
            <input id="firmwareFile" ref="firmwareInput" class="file-input" type="file" accept=".bin" @change="handleFirmwareSelect">
            <div class="hint">Use the same Wi-Fi network and keep this page open until the board reboots.</div>
          </div>
        </div>
        <div class="actions" style="justify-content:flex-start;">
          <button class="btn" :disabled="ota.busy || !ota.file" @click="uploadFirmware">
            {{ ota.busy ? 'Uploading...' : 'Upload Firmware' }}
          </button>
          <button class="btn secondary" :disabled="ota.busy" @click="clearFirmware">Clear</button>
          <button class="btn secondary" :disabled="hardwareLoading" @click="loadHardware">
            {{ hardwareLoading ? 'Loading...' : 'Load Hardware Info' }}
          </button>
        </div>
        <p class="status" v-if="ota.status">{{ ota.status }}</p>
        <div v-if="hardware" class="hw-grid">
          <div class="hw-item">
            <p class="hw-key">Chip ID</p><p class="hw-val">{{ hex(hardware.chipId) }}</p>
          </div>
          <div class="hw-item">
            <p class="hw-key">CPU MHz</p><p class="hw-val">{{ hardware.cpuMHz }}</p>
          </div>
          <div class="hw-item">
            <p class="hw-key">Flash (reported)</p><p class="hw-val">{{ kb(hardware.flashSizeId) }}</p>
          </div>
          <div class="hw-item">
            <p class="hw-key">Flash (real)</p><p class="hw-val">{{ kb(hardware.flashSizeReal) }}</p>
          </div>
          <div class="hw-item">
            <p class="hw-key">Flash Speed</p><p class="hw-val">{{ hardware.flashSpeed }} Hz</p>
          </div>
          <div class="hw-item">
            <p class="hw-key">Flash Mode</p><p class="hw-val">{{ hardware.flashMode }}</p>
          </div>
          <div class="hw-item">
            <p class="hw-key">Sketch Size</p><p class="hw-val">{{ kb(hardware.sketchSize) }}</p>
          </div>
          <div class="hw-item">
            <p class="hw-key">Free Sketch</p><p class="hw-val">{{ kb(hardware.freeSketchSpace) }}</p>
          </div>
          <div class="hw-item">
            <p class="hw-key">Free Heap</p><p class="hw-val">{{ hardware.freeHeap }} B</p>
          </div>
          <div class="hw-item" v-if="hardware.sdkVersion">
            <p class="hw-key">SDK</p><p class="hw-val">{{ hardware.sdkVersion }}</p>
          </div>
          <div class="hw-item" v-if="hardware.resetReason">
            <p class="hw-key">Reset Reason</p><p class="hw-val">{{ hardware.resetReason }}</p>
          </div>
          <div class="hw-item" v-if="hardware.littlefs">
            <p class="hw-key">LittleFS Total</p><p class="hw-val">{{ kb(hardware.littlefs.total) }}</p>
          </div>
          <div class="hw-item" v-if="hardware.littlefs">
            <p class="hw-key">LittleFS Used</p><p class="hw-val">{{ kb(hardware.littlefs.used) }}</p>
          </div>
          <div class="hw-item" v-if="hardware.littlefs">
            <p class="hw-key">LittleFS Free</p><p class="hw-val">{{ kb(hardware.littlefs.free) }}</p>
          </div>
          <div class="hw-item" v-if="hardware.network">
            <p class="hw-key">IP</p><p class="hw-val">{{ hardware.network.ip }}</p>
          </div>
          <div class="hw-item" v-if="hardware.network">
            <p class="hw-key">SSID</p><p class="hw-val">{{ hardware.network.ssid }}</p>
          </div>
          <div class="hw-item" v-if="hardware.network">
            <p class="hw-key">RSSI</p><p class="hw-val">{{ hardware.network.rssi }} dBm</p>
          </div>
          <div class="hw-item" v-if="hardware.uptimeMillis !== undefined">
            <p class="hw-key">Uptime (ms)</p><p class="hw-val">{{ hardware.uptimeMillis }}</p>
          </div>
        </div>
      </article>
    </section>
  </div>

  <script src="vue.js"></script>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          modeKeys: { schedule: 1, timer: 2, manual: 3, off: 4 },
          modeOptions: [
            { key: 4, label: 'Off' },
            { key: 3, label: 'Manual' },
            { key: 2, label: 'Timer' },
            { key: 1, label: 'Scheduler' }
          ],
          channels: [],
          ds3231: null,
          loading: true,
          saving: false,
          clockBusy: false,
          message: '',
          ota: {
            file: null,
            status: '',
            busy: false
          },
          hardware: null,
          hardwareLoading: false,
          pinCtrl: {
            pin: 0,
            state: null,
            busy: false,
            message: ''
          }
        };
      },
      computed: {
        formattedClock() {
          if (!this.ds3231) return '—';
          const y = 2000 + Number(this.ds3231.year || 0);
          return `${this.pad(this.ds3231.hour)}:${this.pad(this.ds3231.minute)}:${this.pad(this.ds3231.second)} ${this.pad(this.ds3231.day)}/${this.pad(this.ds3231.month)}/${y}`;
        }
      },
      methods: {
        pad(value) {
          return String(value).padStart(2, '0');
        },
        toNumber(value) {
          const n = parseInt(value, 10);
          return Number.isFinite(n) ? n : 0;
        },
        timeString(slot) {
          return `${this.pad(slot.startHour)}:${this.pad(slot.startMinute)}`;
        },
        endTime(slot) {
          const start = (this.toNumber(slot.startHour) * 60) + this.toNumber(slot.startMinute);
          const total = start + this.toNumber(slot.durationMin);
          const hh = this.pad(Math.floor((total % 1440) / 60));
          const mm = this.pad(total % 60);
          return `${hh}:${mm}`;
        },
        updateStart(slot, value) {
          const [h, m] = value.split(':').map(v => this.toNumber(v));
          slot.startHour = h;
          slot.startMinute = m;
        },
        updateTimer(channel, key, value) {
          channel.timer[key] = this.toNumber(value);
        },
        setMode(channel, mode) {
          channel.mode = mode;
        },
        async loadChannels() {
          const res = await fetch('channels.json');
          if (!res.ok) throw new Error(res.statusText);
          this.channels = await res.json();
        },
        async loadClock() {
          const res = await fetch('DS3231.json');
          if (!res.ok) throw new Error(res.statusText);
          this.ds3231 = await res.json();
        },
        async refreshAll() {
          this.loading = true;
          this.message = '';
          try {
            await Promise.all([this.loadChannels(), this.loadClock()]);
          } catch (err) {
            this.message = `Error loading data: ${err.message}`;
          } finally {
            this.loading = false;
          }
        },
        async saveChannels() {
          this.saving = true;
          this.message = '';
          try {
            const res = await fetch('channels.json', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(this.channels)
            });
            if (!res.ok) throw new Error(res.statusText);
            this.message = 'Channels saved';
          } catch (err) {
            this.message = `Save failed: ${err.message}`;
          } finally {
            this.saving = false;
          }
        },
        async refreshClock() {
          this.clockBusy = true;
          this.message = '';
          try {
            await this.loadClock();
          } catch (err) {
            this.message = `Clock refresh failed: ${err.message}`;
          } finally {
            this.clockBusy = false;
          }
        },
        async updateClock() {
          this.clockBusy = true;
          this.message = '';
          try {
            const now = new Date();
            const payload = {
              hour: now.getHours(),
              minute: now.getMinutes(),
              second: now.getSeconds(),
              year: now.getFullYear() - 2000,
              month: now.getMonth() + 1,
              day: now.getDate()
            };
            const res = await fetch('DS3231.json', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (!res.ok) throw new Error(res.statusText);
            await this.loadClock();
            this.message = 'Clock updated';
          } catch (err) {
            this.message = `Clock update failed: ${err.message}`;
          } finally {
            this.clockBusy = false;
          }
        },
        handleFirmwareSelect(event) {
          const [file] = event.target.files;
          this.ota.file = file || null;
          if (file) {
            const sizeKb = (file.size / 1024).toFixed(1);
            this.ota.status = `Selected ${file.name} (${sizeKb} KB)`;
          } else {
            this.ota.status = '';
          }
        },
        clearFirmware() {
          this.ota.file = null;
          this.ota.status = '';
          if (this.$refs.firmwareInput) {
            this.$refs.firmwareInput.value = '';
          }
        },
        async uploadFirmware() {
          if (!this.ota.file) {
            this.ota.status = 'Choose a .bin file first.';
            return;
          }
          this.ota.busy = true;
          this.ota.status = 'Uploading... device will reboot when done.';
          try {
            const form = new FormData();
            form.append('update', this.ota.file);
            const res = await fetch('/update', {
              method: 'POST',
              body: form
            });
            const text = await res.text();
            if (!res.ok) throw new Error(text || res.statusText);
            this.ota.status = 'Upload finished. Device will reboot now. Wait ~30s, then reload this page.';
          } catch (err) {
            this.ota.status = `Upload failed: ${err.message}`;
          } finally {
            this.ota.busy = false;
          }
        },
        async loadHardware() {
          this.hardwareLoading = true;
          this.message = '';
          try {
            const res = await fetch('/hardware.json');
            if (!res.ok) throw new Error(res.statusText);
            this.hardware = await res.json();
          } catch (err) {
            this.message = `Hardware info failed: ${err.message}`;
          } finally {
            this.hardwareLoading = false;
          }
        },
        kb(bytes) {
          if (!bytes && bytes !== 0) return '—';
          return `${(bytes / 1024).toFixed(1)} KB`;
        },
        hex(val) {
          if (val === undefined || val === null) return '—';
          return '0x' + Number(val).toString(16).toUpperCase().padStart(6, '0');
        },
        async readPin() {
          const pin = this.pinCtrl.pin;
          if (pin < 0 || pin > 15) {
            this.pinCtrl.message = 'Pin must be 0-15';
            return;
          }
          this.pinCtrl.busy = true;
          this.pinCtrl.message = '';
          try {
            const res = await fetch(`/pin?i=${pin}`);
            if (!res.ok) throw new Error(res.statusText);
            const data = await res.json();
            this.pinCtrl.state = !!data.state;
            this.pinCtrl.message = `Pin ${pin} is ${data.state ? 'HIGH' : 'LOW'}`;
          } catch (err) {
            this.pinCtrl.message = `Read failed: ${err.message}`;
          } finally {
            this.pinCtrl.busy = false;
          }
        },
        async setPin(state) {
          const pin = this.pinCtrl.pin;
          if (pin < 0 || pin > 15) {
            this.pinCtrl.message = 'Pin must be 0-15';
            return;
          }
          this.pinCtrl.busy = true;
          this.pinCtrl.message = '';
          try {
            const res = await fetch('/pin', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ pin, state })
            });
            if (!res.ok) throw new Error(res.statusText);
            const data = await res.json();
            this.pinCtrl.state = !!data.state;
            this.pinCtrl.message = `Pin ${pin} set ${data.state ? 'HIGH' : 'LOW'}`;
          } catch (err) {
            this.pinCtrl.message = `Write failed: ${err.message}`;
          } finally {
            this.pinCtrl.busy = false;
          }
        }
      },
      mounted() {
        this.refreshAll();
      }
    }).mount('#app');
  </script>
</body>
</html>
